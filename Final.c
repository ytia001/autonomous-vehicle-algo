#pragma config(Sensor, in1,    disSensor1,     sensorAnalog)
#pragma config(Sensor, in2,    disSensor2,     sensorAnalog)
#pragma config(Sensor, in3,    disSensor_back, sensorAnalog)
#pragma config(Sensor, in4,    lineSensorL1,   sensorLineFollower)
#pragma config(Sensor, in5,    lineSensorL2,   sensorLineFollower)
#pragma config(Sensor, in6,    lineSensorR2,   sensorLineFollower)
#pragma config(Sensor, in7,    lineSensorR1,   sensorLineFollower)
#pragma config(Sensor, dgtl1,  limit1,         sensorTouch)
#pragma config(Sensor, dgtl2,  limit2,         sensorTouch)
#pragma config(Sensor, dgtl3,  limit_inside,   sensorTouch)
#pragma config(Sensor, dgtl4,  on_off_switch,  sensorTouch)
#pragma config(Sensor, dgtl6,  compassN,       sensorDigitalIn)
#pragma config(Sensor, dgtl7,  compassE,       sensorDigitalIn)
#pragma config(Sensor, dgtl8,  compassS,       sensorDigitalIn)
#pragma config(Sensor, dgtl9,  compassW,       sensorDigitalIn)
#pragma config(Sensor, dgtl10, door_encoder,   sensorQuadEncoder)
#pragma config(Motor,  port2,           rightMotor,    tmotorServoContinuousRotation, openLoop, driveRight)
#pragma config(Motor,  port3,           leftMotor,     tmotorServoContinuousRotation, openLoop, reversed, driveLeft)
#pragma config(Motor,  port4,           rollerMotor,   tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port5,           servoMotor,    tmotorServoStandard, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

int robotDirection;
int rollerspeed = -127;
bool vehicleDetected = false;
bool vehicleClose = false;

task oppVehicleStatus() { //Status that a vehicle is in front is kept on for a time, renew status if detected again
    int startTime;
    int timeLimit = 5; // time limit in 1/10th seconds
    int distance_o;

    while (true) {

        if ( (time100[T2]-startTime) >= timeLimit) {
            vehicleDetected = false;
        }

        distance_o = SensorValue[disSensor2];

        if (distance_o > 800) {

            vehicleDetected = true;
            startTime = time100[T2];
        }
    }
}


task CaptureDirection() //compass
{
    while(true){
    int compassValue = 8*SensorValue(compassW)+4*SensorValue(compassS)+2*SensorValue(compassE)+SensorValue(compassN);
    switch(compassValue){
        case 15:
            robotDirection = 1; //North
            break;
        case 12:
            robotDirection = 2; //North-Easta
            break;
        case 13:
            robotDirection = 3; //East
            break;
        case 9:
            robotDirection = 4; //South-East
            break;
        case 11:
            robotDirection = 5; //South
            break;
        case 3:
            robotDirection = 6; //South-West
            break;
        case 7:
            robotDirection = 7; //West
            break;
        case 6:
            robotDirection = 8; //North-west
            break;
        default:
            break;
        }
    }
}

// Detect vehicle current orientation & rotate itself until it faces south
void faceSouth()
{
	int turnSpeed = 50;
		// If vehicle initial orientation is anywhere at north to south-east, rotate clockwise till it faces south
    if (robotDirection >= 1 && robotDirection < 5){
	    while(robotDirection != 5)
	    {
	        motor[leftMotor] = 	turnSpeed;
          motor[rightMotor] = -turnSpeed;//cw
	     }
	}
	// If vehicle initial orientation is anywhere at south-west to north-west, rotate counterClockwise till it faces south
	else if (robotDirection > 5 && robotDirection <= 8){
	    while(robotDirection != 5)
	    {
	        motor[leftMotor] = -turnSpeed;
          motor[rightMotor] = turnSpeed;//ccw
	    }
	 }
	 // If it is already faces south, stop its motion
    else{
	    motor[leftMotor] = 0;
	    motor[rightMotor] = 0;
	}
}

bool detectYellow(){
	int frontThreshold = 800;
	int backThreshold = 1800;
    	int sense1 = SensorValue(lineSensorL1);
	int sense2 = SensorValue(lineSensorR1);
	int sense3 = SensorValue(lineSensorL2);
	int sense4 = SensorValue(lineSensorR2);

	int turnSpeed = 50;	    //change turn speed so that it doesnt stuck at edge
    	int backSpeed = -40;

  //Front detect yellow line
	if( sense1 < frontThreshold || sense2 < frontThreshold ){
			// Left detect yellow line
        if(sense1 < frontThreshold){
            motor[leftMotor] = backSpeed;
            motor[rightMotor] = backSpeed;
            wait1Msec(800);
            // Turn to the right direction
            motor[leftMotor] = turnSpeed;
            motor[rightMotor] = -turnSpeed;
            wait1Msec(400);
        }
        else if(sense2 < frontThreshold){
        // Right detect yellow line
            motor[leftMotor] = backSpeed;
            motor[rightMotor] = backSpeed;
            wait1Msec(800);
            // Turn to the left direction
            motor[leftMotor] = - turnSpeed;
            motor[rightMotor] = turnSpeed;
            wait1Msec(400);
        }

    }

   // Back detect yellow line
	else if ( sense3 < backThreshold || sense4 < backThreshold){
	   //Left detect yellow
        if(sense3 < backThreshold){
            motor[leftMotor] = -backSpeed;
            motor[rightMotor] = -backSpeed;
            wait1Msec(800);
            // Turn to the left direction
            motor[leftMotor] = -turnSpeed;
            motor[rightMotor] = turnSpeed;
            wait1Msec(140);
        }
        else if(sense4 < backThreshold){
            //right detect yellow
            motor[leftMotor] = -backSpeed;
            motor[rightMotor] = -backSpeed;
            wait1Msec(800);
            //Turn to the right direction
            motor[leftMotor] = turnSpeed;
            motor[rightMotor] = -turnSpeed;
            wait1Msec(140);
        }

	}
	// If no detect yellow line , return false, if detected yellow line, return true
	else{
	  	return false;
	}

	clearTimer(T3);
	clearTimer(T1);
	return true;
}

bool detectYellow2(){

    int threshold = 800;
    int sense1 = SensorValue(lineSensorL1);
    int sense2 = SensorValue(lineSensorR1);

    int turnSpeed = 40;    //change turn speed so that it doesnt stuck at edge
    int backSpeed = -30;

    //Front detect yellow line
    if( sense1 < threshold || sense2 < threshold ){
   // Left detect yellow line
        if(sense1 < threshold){
            motor[leftMotor] = backSpeed;
            motor[rightMotor] = backSpeed;
            wait1Msec(500);
            // Turn to the right direction
            motor[leftMotor] = turnSpeed;
            motor[rightMotor] = -turnSpeed;
            wait1Msec(200);
        }
        else if(sense2 < threshold){
        // Right detect yellow line
            motor[leftMotor] = backSpeed;
            motor[rightMotor] = backSpeed;
            wait1Msec(500);
            // Turn to the left direction
            motor[leftMotor] = -turnSpeed;
            motor[rightMotor] = turnSpeed;
            wait1Msec(200);
        }

    }
  // If no detect yellow line , return false, if detected yellow line, return true
    else{
        return false;
    }
return true;
}

void detectVehicle(){       // Added below detectYellow() and detectYellow2()
	int threshold = 1800;  // very high threshold indicate opponent very close to vehicle
    	int backSensor = SensorValue(disSensor_back);
	int frontSensor = SensorValue(disSensor2);

	int turnSpeed = 50;				//change turn speed so that it is able to move around the opponent
    	int backSpeed = -40;			//change back speed so that it can move away from opponent and leave enough gap
	vehicleClose = false;
     //how to know whether to rotate left or right?

    //Front detect vehicle
	if( frontSensor >= threshold ){
            vehicleClose = true;
            motor[leftMotor] = backSpeed;
            motor[rightMotor] = backSpeed;
            wait1Msec(800);
            // Turn to the right direction
            motor[leftMotor] = turnSpeed;
            motor[rightMotor] = -turnSpeed;
            wait1Msec(1000);
            // Turn to the left direction
            //motor[leftMotor] = -turnSpeed;
            //motor[rightMotor] = turnSpeed;
            //wait1Msec(1000);
    }
   // Back detect vehicle
	else if ( backSensor >= threshold){
            motor[leftMotor] = -backSpeed;
            motor[rightMotor] = -backSpeed;
            wait1Msec(600);
            // Turn to the right direction
            motor[leftMotor] = turnSpeed;
            motor[rightMotor] = -turnSpeed;
            wait1Msec(800);
            motor[leftMotor] = -backSpeed;
            motor[rightMotor] = -backSpeed;
            wait1Msec(600);
	}
		// If no detection of opponent ,return ,if detected opponent,reset timer then return ?
	else{
	  	return;
	}
	//clear Timer?
	clearTimer(T3);
	clearTimer(T1);
	return;
}



//////////ball finding function//////////
void findBall()
{
    bool ballDetected = false;
    int turnSpeed = 40; // adjust to desired turning speed
    int searchTime = 6000; // 360 degrees = 3600 milliseconds at speed 30
    const int DETECT_DISTANCE = 800; //Distance in mm to detect tennis ball
    //const int DETECT_OPPONENT = 800; //distance to opponent
    faceSouth();
    clearTimer(T1);

    while (!ballDetected && time1[T1] < searchTime) {
        int distance = SensorValue[disSensor1];
        int distance_o = SensorValue[disSensor2];
        if (distance >= DETECT_DISTANCE && vehicleDetected == false) {
            ballDetected = true;
            motor[leftMotor] = 0;
            motor[rightMotor] = 0;
            wait1Msec(500);
        }
        else {

        	// search in a certain range (option1)
            if (SensorValue[limit_inside] == 1){
                ballDetected = true;
                break;
          	}
        		else if(time1[T1] <= 1000){
            	bool detect = detectYellow();
                detectVehicle();
	    		if(!detect){
		            motor[leftMotor] = -turnSpeed;
		            motor[rightMotor] = turnSpeed;
		        }
			}
            else if (time1[T1] > 1000 && time1[T1] <= 3100 ){
				bool detect = detectYellow();
                detectVehicle();
	    		if(!detect){
                    motor[leftMotor] =  turnSpeed+15;
		            motor[rightMotor] = -turnSpeed;
		        }
			}
            else if (time1[T1] > 3100 && time1[T1] <= 4100 ){
				bool detect = detectYellow();
                detectVehicle();
	    		if(!detect){
					motor[leftMotor] = -turnSpeed;
		            motor[rightMotor] = turnSpeed;
		        }
			}
            else{
				break;
			}

			 // search 360 , no range (option2)
			//   detectYellow();
            //   motor[leftMotor] = -turnSpeed;
            //   motor[rightMotor] = turnSpeed;
        }
    }

    if (!ballDetected) {
        // if ball not found, move forward and try again
        clearTimer(T3);
        faceSouth();
        while(time1[T3] < 1200){
        bool detect = detectYellow();
        detectVehicle();
            if(!detect){
                motor[leftMotor] = 40;
                motor[rightMotor] = 35;
	      	}
      	} // move forward for 1 second
        findBall(); // recursively call findBall to start searching again
    }
}


///////////ball collecting function//////////
bool collectBall() {
    bool ballCollected = false;
    int driveSpeed = 40; // adjust to desired driving speed
    int catchSpeed = 40;
    int collectTime = 10000; // time taken to collect ball, if exceeded means ball got swept/push/stuck, execute findBall() again
    const int STOP_DISTANCE = 2000;// Distance in mm to tennis ball to stop
	int distance;

    clearTimer(T1);
    while (!ballCollected && time1[T1] < collectTime ) {
        detectYellow2();
        detectVehicle();
        motor[leftMotor] = driveSpeed;
        motor[rightMotor] = driveSpeed;

        if (vehicleClose == true){ //in collect ball
            break;
            }

        distance = SensorValue[disSensor1];
        if (distance >= STOP_DISTANCE) { // if limit switch is pressed, ball is collected
            motor[leftMotor] = catchSpeed;
            motor[rightMotor] = catchSpeed;
            wait1Msec(500);
            motor[leftMotor] = -catchSpeed;
            motor[rightMotor] = -catchSpeed;
            wait1Msec(500);
            motor[leftMotor] = 0;
            motor[rightMotor] = 0;
        }

        if (SensorValue[limit_inside] == 1) { // if limit switch is pressed, ball is collected
            ballCollected = true;
            //motor[rollerMotor] = 0;
        }
    }


    //if ball still not collected after 15s , execute findBall() again
    if(!ballCollected){
        distance = SensorValue[disSensor1];
        if (distance >= STOP_DISTANCE){ //if its still close in front means the robot is stuck at the backboard, hence reverse
            motor[leftMotor] = -driveSpeed;
            motor[rightMotor] = -driveSpeed;
            wait1Msec(1000);
        }
        return false;
 	}
    else
    {
 		return true;
 	}
}


////////////ball releasing function//////////
void releaseBall()
{
    int encoder_value = -35;
    int encoder_stop_value = 1;
    int obstacle_distance = 800;
    int servo_speed = -50;
	//adjust direction using compass here & ensure:
    faceSouth();
    clearTimer(T4);

    while((SensorValue[limit1] && SensorValue[limit2])!= 1 && time1[T4] < 10000) {
        detectYellow();
        //move backward
        motor[leftMotor] = -40;
        motor[rightMotor] = -30;
        //check direction
        wait1Msec(100);
        faceSouth();
        //check obstacle
        detectVehicle();
        //while (SensorValue[disSensor_back]>= obstacle_distance){
        //	motor[leftMotor] = 0;
        //	motor[rightMotor] = 0;
        //}
    }

    if (time1[T4] >= 10000)
    {
    	motor[leftMotor] = 40;
        motor[rightMotor] = 30;
        //check direction
        wait1Msec(1000);
        faceSouth();
        releaseBall();
  	}

    motor[leftMotor] = 0;
    motor[rightMotor] = 0;

    // move the servo to release the ball
    while (SensorValue[door_encoder]> encoder_value){
    	motor[servoMotor] = servo_speed;
	}

    // reset the servo and the motor
    motor[servoMotor] = 0;
    wait1Msec(1500);

    while (SensorValue[door_encoder]< encoder_stop_value){
        motor[servoMotor] = -servo_speed;
    }
}



////////////////main task start/////////////////////
task main()
{
    // Check the switch to turn on/off the robot
    while(SensorValue[on_off_switch] == 0) {
    // wait for the limit switch to be pressed

      // start task
    	clearTimer(T2);
		startTask(oppVehicleStatus);
        startTask(CaptureDirection);
        wait1Msec(100);
    }

    motor[rollerMotor] = rollerspeed; //start roller

    while(true) {
    	//initialize encoder value
        SensorValue[door_encoder] = 0;

        while (SensorValue[door_encoder] < 1){
    		motor[servoMotor] = 50;
        }
    	motor[servoMotor] = 0;

       // Move straight to the center/suitable spot
    	// Make sure line sensor doesnt touch yellow line at the start
    	// Make sure vehicle move straight not sideways
        clearTimer(T4);
        while(time1[T4] < 2200){
            bool detect = detectYellow();
            detectVehicle();
            if(!detect){
                motor[rightMotor] = 45;
                motor[leftMotor] = 60;
            }
        }

        while(1){
            // Find the ball
            findBall();

            //go and collect ball
            bool ballCollected = collectBall();

            //check if ball collcted , yes break , no continue find ball
            if(ballCollected){
                break;
            }
     	}
        // Release the ball
        releaseBall();
    }

}
